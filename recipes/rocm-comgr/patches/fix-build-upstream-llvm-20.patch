
diff --git a/amd/comgr/src/comgr-cache.cpp b/amd/comgr/src/comgr-cache.cpp
index 3fdc71a74e790..4aa5cb93e4cb5 100644
--- a/amd/comgr/src/comgr-cache.cpp
+++ b/amd/comgr/src/comgr-cache.cpp
@@ -130,7 +130,9 @@ void saveCommandOutput(CachedCommandAdaptor &C, AddStreamFn &AddStream,
 
   CachedFileStream *CFS = FileOrErr->get();
   serializeCacheEntry(*CFS->OS, *Buffer, CapturedLogS);
-  ErrorHandler(CFS->commit(), "when commiting file stream");
+  // in clang 20, the commit is performed in the CFS destructor.
+  // ErrorHandler(CFS->commit(), "when commiting file stream");
+  static_assert(LLVM_VERSION_MAJOR == 20, "This patch is meant to be used with llvm 20");
 }
 
 bool readEntryFromCache(CachedCommandAdaptor &C, MemoryBuffer &CachedBuffer,

diff --git a/amd/comgr/src/comgr-cache-bundler-command.cpp b/amd/comgr/src/comgr-cache-bundler-command.cpp
index 5142627254d64..186205aca68ef 100644
--- a/amd/comgr/src/comgr-cache-bundler-command.cpp
+++ b/amd/comgr/src/comgr-cache-bundler-command.cpp
@@ -152,10 +152,46 @@ void UnbundleCommand::addOptionsIdentifier(HashAlgorithm &H) const {
   }
 }
 
+// V3HeaderSize is not public in stock clang 20, and CompressedOffloadBundle::getHeaderSize 
+// is not constexpr, so we reimplement it here by copying the value from https://github.com/llvm/llvm-project/blob/llvmorg-20.1.8/clang/include/clang/Driver/OffloadBundler.h#L132
+class CompressedOffloadBundleLocalCopyLLVM20 {
+public:
+  static inline const size_t MagicSize = 4;
+  static inline const size_t VersionFieldSize = sizeof(uint16_t);
+  static inline const size_t MethodFieldSize = sizeof(uint16_t);
+  // Legacy size fields for V1/V2
+  static inline const size_t FileSizeFieldSizeV2 = sizeof(uint32_t);
+  static inline const size_t UncompressedSizeFieldSizeV2 = sizeof(uint32_t);
+  // New size fields for V3
+  static inline const size_t FileSizeFieldSizeV3 = sizeof(uint64_t);
+  static inline const size_t UncompressedSizeFieldSizeV3 = sizeof(uint64_t);
+  static inline const size_t HashFieldSize = sizeof(uint64_t);
+
+  // Keep V1 header size for backward compatibility
+  static inline const size_t V1HeaderSize =
+      MagicSize + VersionFieldSize + MethodFieldSize +
+      UncompressedSizeFieldSizeV2 + HashFieldSize;
+
+  // Keep V2 header size for backward compatibility
+  static inline const size_t V2HeaderSize =
+      MagicSize + VersionFieldSize + FileSizeFieldSizeV2 + MethodFieldSize +
+      UncompressedSizeFieldSizeV2 + HashFieldSize;
+
+  // Add V3 header size with 64-bit fields
+  static inline const size_t V3HeaderSize =
+      MagicSize + VersionFieldSize + FileSizeFieldSizeV3 + MethodFieldSize +
+      UncompressedSizeFieldSizeV3 + HashFieldSize;
+
+  static inline const llvm::StringRef MagicNumber = "CCOB";
+};
+// Let's keep a static assert that we are indeed using llvm 20, otherwise the patch may fail silently
+static_assert(LLVM_VERSION_MAJOR == 20, "This patch is meant to be used with llvm 20");
+
+
 Error UnbundleCommand::addInputIdentifier(HashAlgorithm &H) const {
   StringRef InputFilename = Config.InputFileNames.front();
 
-  constexpr size_t LargestHeaderSize = CompressedOffloadBundle::V3HeaderSize;
+  constexpr size_t LargestHeaderSize = CompressedOffloadBundleLocalCopyLLVM20::V3HeaderSize;
 
   ErrorOr<std::unique_ptr<MemoryBuffer>> MaybeInputBuffer =
       MemoryBuffer::getFileSlice(InputFilename, LargestHeaderSize, 0);
